# Sigmal Language Specification — Part 04
# Surface Syntax and Core Syntax Constraints

[Top](../../) &gt; [Design docs](../) &gt; [Core design](./) &gt; **Part 04**

---

Sigmal surface syntax is:

* Fully expression-based
* Free of reserved alphanumeric keywords
* Deterministic to parse
* Structurally uniform
* Free of context-sensitive reinterpretation

All constructs are expressions.

---

## 1. Lexical Structure

### 1.1 Identifiers

Identifiers:

* Begin with a letter
* May contain letters, digits, and `_`
* Are case-sensitive

Identifiers are never reserved.

Their meaning depends solely on syntactic position.

---

### 1.2 Reserved Symbols

Only symbolic tokens are reserved:

```
\     abstraction
$     universe
@     symbol injection
&     record
##     inductive
.     projection
{ }   block
( )   grouping
:     type annotation
=     binding (blocks/records)
;     definition separator
->    arrow sugar
^     pattern match
=>    match arm separator
```

No alphanumeric keyword is reserved.

---

## 2. Expressions

All constructs are expressions.

There are no statements.

There is no `let`, `import`, or `match` keyword.

---

## 3. Abstraction

Dependent abstraction:

```sigmal
\ (x : A) = body
```

This form serves both:

* Dependent function type
* Lambda term

Multiple parameters:

```sigmal
\ (x : A)
  (y : B)
= body
```

Arrow sugar:

```sigmal
A -> B
```

means:

```sigmal
\ (_ : A) = B
```

---

## 4. Application

Application is whitespace-based.

```sigmal
f x
f x y
g f x
```

Application is left-associative:

```
f x y  ≡  (f x) y
```

Parentheses are used only for grouping:

```sigmal
f (g x)
```

Parentheses are not used for function calls.

---

## 5. Records

### 5.1 Record Types

```sigmal
&{
  k1 : T1;
  k2 : T2;
}
```

### 5.2 Record Values

```sigmal
&{
  k1 = v1;
  k2 = v2;
}
```

Field order is irrelevant.

Trailing semicolon inside records is optional.

---

## 6. Inductive Types

```sigmal
#{
  C1;
  C2(T);
}
```

Constructors may carry arguments.

---

## 7. Pattern Matching

Pattern matching uses `^`:

```sigmal
^ x {
  C1 => e1;
  C2(y) => e2;
}
```

Patterns must be exhaustive.

`^` introduces a match expression.

`=>` separates patterns from result expressions.

---

## 8. Projection

Projection uses `.`.

```sigmal
r.k
```

means:

```sigmal
r.@{ TextSym "k" }
```

Projection is left-associative:

```sigmal
a.b.c
```

means:

```sigmal
(a.b).c
```

There is no alternate meaning of `.` anywhere in the language.

---

## 9. Top-Level Module Access

Bare `.` is an expression.

If a resolver provides a top-level module record, then:

```sigmal
.std.alloc
```

is simply projection from that record.

A resolver may choose to interpret `.` as it considers sensible, provided resolution is deterministic.

For example:

* `.` may evaluate to a record containing all registered modules.
* `.` may evaluate to an empty record.
* `.` may be unsupported.

Accepting `.` as a top-level module value is not required by the core language.

The core language only defines `.` as projection.

---

## 10. Symbol Injection

Symbol injection syntax:

```sigmal
@{ e }
```

where:

* `e : Sym`
* `e` must be const-normalizable

Valid only in symbol-key positions:

* Record fields
* Constructor names
* Projection keys
* Module path segments
* Bindings in blocks

Identifiers in key positions are sugar for:

```sigmal
@{ TextSym "identifier" }
```

> TODO: standardize on the exact path of `*Sym` values.
> Currently, it is only specified that symbol utilities are provided by `.std.core`.

---

## 11. Universes

Universe levels:

```sigmal
$ { e }
```

where:

* `e : Nat`
* `e` must be const-normalizable

Sugar:

```sigmal
$0  ≡  $ { 0 }
$1  ≡  $ { 1 }
```

---

## 12. Top-Level Structure

A source file consists of:

* Zero or more definitions
* A final expression

Definition syntax:

```sigmal
name = expr;
```

The final expression:

* Has no trailing `;`
* Determines the value of the compilation unit

There is no implicit wrapping of definitions into a record.

If the final expression is a record, the compilation unit may serve as a namespace.

If not, it is simply a value.

---

## 13. Comments

Single-line comments:

```sigmal
// comment
```

Block comments:

```sigmal
/* comment */
```

Block comment nesting is implementation-defined.

---

## 14. Deterministic Parsing

Parsing is deterministic because:

* `\ (...) { ... }` always introduces abstraction
* `^ expr { ... }` always introduces match
* `&{ ... }` always introduces record
* `#{ ... }` always introduces inductive
* `$ { ... }` always introduces universe
* `@{ ... }` always introduces symbol injection
* `.` is always projection
* `=>` appears only inside match arms

No token changes meaning based on context.

There are no reserved alphanumeric keywords.

---

## 15. Summary

Sigmal surface syntax:

* Uses only symbolic reserved tokens
* Has zero reserved alphanumeric keywords
* Uses whitespace for application
* Uses `\` for abstraction
* Uses `^` for pattern matching
* Uses `.` for projection everywhere
* Allows `.` as an expression
* Leaves module resolution to the resolver
* Requires explicit record return in modules
* Preserves structural clarity and determinism

All syntax corresponds directly to core semantic constructs.

---

**Sigmal.org** - *the calculus we can build on*
