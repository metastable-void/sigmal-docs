# Sigmal Language Specification — Part 01
# Design Goals and Philosophy

[Top](../../) &gt; [Design docs](../) &gt; [Core design](./) &gt; **Part 01**

## 1. Vision

Sigmal is a pure, total, compiled programming language designed to combine:

* Coq-like logical generality
* Haskell-like abstraction ergonomics
* Rust-like systems feel (without sacrificing purity or totality)
* Minimal runtime assumptions

Sigmal is not an interpreted scripting language.
It is intended to compile to low-level targets (LLVM, WASM, native) while preserving strong logical guarantees.

At its logical core, Sigmal is based on the **Calculus of Constructions (CoC)**.
The core type system is a stratified, total, dependent λ-calculus in which terms and types inhabit a unified hierarchy of universes.

The goal is to provide a language suitable for:

* Verified systems programming
* High-assurance infrastructure
* Logic-heavy applications
* Freestanding environments

without sacrificing explicitness or determinism.

---

## 2. Core Principles

### 2.0 Calculus of Constructions Foundation

Sigmal’s core calculus is a stratified form of the **Calculus of Constructions (CoC)**.

Specifically:

- Dependent function types (Π-types) and lambda abstraction form a unified abstraction mechanism.
- Types are ordinary terms living in universes.
- Universes are stratified to preserve consistency.
- There is no distinction between “type-level” and “term-level” abstraction beyond universe stratification.

Sigmal does not introduce additional primitive abstraction forms beyond those of CoC.
All higher-level constructs (records, inductives, modules) are defined in terms of this core dependent λ-calculus.

### 2.1 Totality

All well-typed programs (as in pure expressions) terminate.

There is no:

* Implicit divergence
* Hidden partiality
* General unrestricted recursion in the core

Termination is a semantic guarantee of the language.

Nontermination, if desired (e.g., event loops), must be expressed explicitly via library-defined effect encodings or control values, and must not be reachable by the compile-time normalization semantics.

---

### 2.2 Purity

The core language is pure.

There are no built-in side effects.

All effects must be modeled explicitly as values.

Effectful behavior, if provided by libraries, is expressed through:

* Explicit data structures
* Explicit capabilities
* Explicit control mechanisms

There are no hidden runtime effects.

---

### 2.3 Structural Typing

Sigmal has no nominal type identity. Type identity is determined structurally within the underlying Calculus of Constructions framework.

Type equality is determined by:

* Normalization
* Structural comparison
* Symbol-keyed identity

There is no subtyping hierarchy.

Two types are equal if their normalized structures are equal.

---

### 2.4 Explicit Evidence

Sigmal performs no implicit property resolution.

If a function depends on a property (equality, ordering, allocation capability, effect handling, etc.), it must receive a witness explicitly.

There is:

* No global instance registry
* No implicit coherence
* No compiler-driven instance search

The only automatic reasoning mechanism is definitional equality.

This follows directly from the CoC foundation: properties are represented as values (types or records), and all reasoning beyond definitional equality must be carried explicitly as terms.

---

### 2.5 Symbols as Identity Atoms

Sigmal uses symbols (`Sym`) as structural identity atoms.

Symbols serve as:

* Record field keys
* Constructor tags
* Module path segments
* Structural identifiers

Symbol equality is structural.

There is no global registry of symbols.

#### 2.5.1 Determinism requirement.

The representation and construction of Sym values may be implementation-defined, but must be deterministic: identical inputs under the same implementation yield symbols with identical structural equality behavior.

---

### 2.6 Compile-Time Normalization

Certain syntactic positions require compile-time normalization.

This normalization corresponds to conversion in the underlying Calculus of Constructions and forms part of definitional equality.

Universe levels and symbol injection require const-normalizable expressions.

Compile-time evaluation:

* Is deterministic
* Is total
* Is effect-free
* Is part of the core semantics

Const evaluation is not an optimization; it is a semantic requirement.

Const evaluation applies only to const-normalizable expressions and must not evaluate library encodings that represent effectful execution or potentially non-terminating control behavior.

---

### 2.7 No Global Namespace

Sigmal defines no global namespace.

All visibility arises from:

* Explicit projection
* Explicit bindings
* Explicit module values

Modules are ordinary values.

There is no implicit visibility of definitions.

---

### 2.8 Modules as Values

A compilation unit evaluates to a value.

If that value is a record, it may serve as a namespace.

Projection (`.`) is the only namespace mechanism.

There is no nominal module identity.

Module resolution is external to the core language.

---

### 2.9 Resolver Independence

The language makes no assumptions about:

* Filesystems
* Package managers
* Linking mechanisms

A resolver may provide a top-level module record.

The resolver must be deterministic.

The core language does not define how resolution occurs.

#### 2.9.1 Standard library namespace.

The resolver provides a standardized `.std.*` namespace. Some modules (e.g. `.std.core`) have fully standardized semantics across all targets. Other modules (e.g. `.std.abi`) have standardized interfaces but may vary in their provided values and behavior across targets, subject to the interface contract.

For a fixed target triple and implementation, `.std.*` modules are deterministic: given the same inputs, they produce the same outputs and compiled artifacts.

Aside from the standardized `.std.*` modules, resolution is unconstrained and implementation-defined.

---

### 2.10 Minimal Reserved Syntax

Sigmal avoids reserved alphanumeric keywords.

Core constructs are introduced using symbolic tokens.

This preserves:

* Extensibility
* Simplicity
* Explicitness

Tokens have deterministic meaning given syntactic form.

Sigmal defines no infix operators. All function application is prefix and explicit. There is no user-defined operator precedence or associativity in v1.

---

### 2.11 Everything Is an Expression

Sigmal has:

* No statements
* No declaration-only constructs
* No implicit nominal module wrapper

A compilation unit evaluates to a value.

All constructs produce values.

A compilation unit is implicitly a block expression: a sequence of bindings followed by a final expression whose value is the unit’s value (or `Unit` if the unit ends with a semicolon).

---

## 3. Compilation Model

Sigmal is a compiled language.

Programs are compiled ahead-of-time to low-level targets.

There is no required runtime interpreter.

The language is designed to support:

* Static linking
* Freestanding execution
* Embedded targets
* Deterministic builds

---

## 4. Compilation Targets

Sigmal aims to support:

* Native targets (Linux, macOS, Windows, FreeBSD)
* `wasm32-unknown-unknown` (freestanding WebAssembly)
* Other freestanding environments

Sigmal makes minimal runtime assumptions.

There is:

* No required garbage collector
* No mandatory runtime system
* No hidden allocation model

A default allocator may be provided by standard libraries.

Reference-counted types are permitted.

Memory management strategies are explicit and library-defined.

---

## 5. Systems Orientation

Sigmal is designed to feel suitable for systems programming while preserving:

* Purity
* Totality
* Explicitness

This includes:

* Predictable memory behavior
* Deterministic compilation
* Low-level target compatibility
* No hidden runtime machinery

The language aims to provide logical guarantees without sacrificing practical systems use.

---

## 6. Determinism

Sigmal is deterministic in:

* Parsing
* Normalization
* Type checking
* Module resolution (given a resolver configuration)

There is no hidden search phase or implicit inference beyond definitional equality.

---

## 7. Summary

Sigmal is:

* Pure
* Total
* Structurally typed
* Symbol-keyed
* Explicit in all properties
* Resolver-agnostic
* Free of global registries
* Free of implicit instance resolution
* Minimal in syntax
* Deterministic
* Compiled to low-level targets
* Based on the Calculus of Constructions

It aims to combine:

* The logical generality of Coq
* The abstraction ergonomics of Haskell
* The systems practicality of Rust

while remaining small, explicit, and structurally coherent.

---

**Sigmal.org** - *the calculus we can build on*
