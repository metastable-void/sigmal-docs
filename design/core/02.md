# Sigmal Language Specification — Part 02
# Core Type System and Universes

[Top](../../) > [Design docs](../) > [Core design](./) > **Part 02**

---

Sigmal is a **pure, total, structurally typed language**.

At its logical core, Sigmal is based on a **minimal Calculus of Inductive Constructions (CIC)**.

Terms and types inhabit a unified dependent λ-calculus with:

* Stratified universes
* Dependent function types (Π-types)
* Inductive families (indexed inductive types)
* Dependent elimination
* Structural definitional equality
* Explicit evidence for all non-definitional properties
* Compile-time const normalization

Sigmal includes only the computational core of CIC. It does not include:

* Tactics
* Proof automation
* Implicit rewriting
* Meta-level proof scripting
* Instance search

There is:

* No nominal type system
* No subtyping
* No global instance registry
* No implicit property resolution

---

# 1. Universes

Universes are indexed by natural numbers.

```
$ { e }
```

Where:

* `e : Nat`
* `e` must be const-normalizable

Syntactic sugar:

```
$0  ≡  $ { 0 }
$1  ≡  $ { 1 }
$2  ≡  $ { 2 }
```

Universe equality is determined by equality of normalized `Nat` values.

Example:

```
$ { + 1 1 }  ≡  $ { 2 }
```

if both expressions normalize to the same `Nat`.

Universes are stratified:

If `A : $ { n }`, then:

```
$ { n } : $ { + n 1 }
```

There is no `Type : Type`.

There is no impredicativity.

This stratification enforces logical consistency of the minimal CIC core.

---

# 2. Dependent Functions and Abstraction

Sigmal uses a single abstraction form:

```
\ (x : A) -> T = B
```

This form represents both:

* Dependent function types (Π-types)
* Lambda abstraction terms

Types are ordinary terms living in universes.

If:

* `A : $ { n }`
* `B : $ { m }` under `x : A`

then:

```
\ (x : A) -> B : $ { max n m }
```

Non-dependent arrow sugar:

```
A -> B
```

is equivalent to:

```
\ (_ : A) -> B
```

---

## 2.1 Function Application

Application uses whitespace and is left-associative:

```
f x y    ≡    (f x) y
```

Parentheses are only for grouping:

```
f (g x)
```

Sigmal defines no infix operators.

---

# 3. Record Types

Record types are finite maps from **symbol keys** to types:

```
&{
  K1 : T1;
  K2 : T2;
}
```

Record types are:

* Structural
* Order-independent
* Non-dependent (field types cannot refer to other fields)

Two record types are definitionally equal iff:

* They contain identical symbol keys
* Corresponding field types are definitionally equal

Record values:

```
&{
  K1 = v1;
  K2 = v2;
}
```

---

# 4. Inductive Families

Inductive types may be **indexed by values**.

General form:

```
Ind =
  \ (params...)
    (indices...)
  -> $ { u }
  = #{
      C1 : T1;
      C2 : T2;
    };
```

Constructors may specify explicit result types.

Example (length-indexed vector):

```
Vec =
  \ (A : $0)
    (n : Nat)
  -> $0
  = #{
      Nil  : Vec A 0;
      Cons : \ (k : Nat) -> A -> Vec A k -> Vec A (S k);
    };
```

Inductive definitions must satisfy:

* Strict positivity
* Well-typed constructor result types

Two inductive families are definitionally equal iff:

* They have identical constructor symbol keys
* Corresponding constructor types are definitionally equal

---

# 4.1 Dependent Elimination

Pattern matching supports dependent elimination.

General form:

```
^ x : Motive {
  C1(args...) => e1;
  C2(args...) => e2;
}
```

Where:

* `Motive` is a type family describing the result type
* All branches must produce terms inhabiting the motive

When non-dependent, motive may be omitted:

```
^ x {
  ...
}
```

Pattern matching must be exhaustive.

---

# 4.2 Propositional Equality

Propositional equality is an inductive family:

```
Eq =
  \ (A : $0)
    (x : A)
    (y : A)
  -> $0
  = #{
      Refl : Eq A x x;
    };
```

No rewriting is performed automatically.

Transport across equality is defined via dependent elimination.

Equality reasoning is explicit.

---

# 5. Symbols (`Sym`)

```
Sym : $0
```

Symbols are structural identity atoms used as:

* Record field keys
* Constructor tags
* Module path segments

Symbol equality is structural.

There is no global registry.

Symbol representation is implementation-defined but must be deterministic.

---

# 6. Symbol Injection

```
@{ e }
```

Where:

* `e : Sym`
* `e` must be const-normalizable

Valid only in symbol-key positions.

Bare identifiers in key positions are sugar for:

```
@{ TextSym "identifier" }
```

Symbol construction utilities are provided by `.std.core`.

---

# 7. Const-Normalizable Expressions

An expression `e` is const-normalizable if:

1. `e` typechecks in the pure fragment
2. `e` is effect-free
3. `e` terminates
4. `e` reduces to a value

We write:

```
Γ ⊢const e ⇓ v
```

Const-required positions include:

* Universe levels `$ { e }`
* Symbol injection `@{ e }`
* Any structural parameter declared const-required

Const evaluation is:

* Deterministic
* Total
* Effect-free

Const evaluation does not execute effect interpreters.

---

# 8. Definitional Equality

Definitional equality corresponds to conversion in minimal CIC.

Definitional equality includes:

* β-reduction
* Structural comparison
* Normalization of const-normalizable expressions

Only const-normalizable expressions participate in definitional equality.

No symbolic rewriting is performed.

Example:

* `Vec A (+ 3 0)` may reduce if `(+ 3 0)` is const-normalizable.
* `Vec A (+ n 0)` is not definitionally equal to `Vec A n`; a proof via `Eq` is required.

No automatic extensional reasoning is performed.

---

# 9. No Runtime Reflection into Types

Runtime values cannot influence type structure unless they appear in const-normalizable positions.

There is:

* No `Sym -> Type` mapping
* No dynamic type construction
* No reflection of runtime values into type indices

Type structure depends only on:

* Syntax
* Const-normalizable expressions
* Definitional equality

---

# 10. Explicit Evidence Discipline

Sigmal performs no implicit property resolution.

If a function requires a property, it must receive a witness explicitly.

The only automatic reasoning mechanism is definitional equality.

All non-definitional reasoning must be expressed via values (e.g., `Eq`).

---

# 11. Typeclasses

Typeclasses are ordinary record types.

There is:

* No global instance registry
* No coherence mechanism
* No implicit resolution

Instances are explicit values.

---

# 12. Literals

Literal interpretation does not depend on implicit resolution.

Conversions must be explicit.

---

# 13. Summary

The Sigmal core type system is:

* Pure
* Total (pure fragment)
* Structural
* Universe-stratified
* Based on minimal CIC
* Supports indexed inductive families
* Uses explicit propositional equality
* Deterministic in compile-time normalization
* Free of implicit reasoning mechanisms

Type identity is structural and determined by normalized form.

All non-definitional properties must be passed explicitly as values.

---

**Sigmal.org** - *the calculus we can build on*
