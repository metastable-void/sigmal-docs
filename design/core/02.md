# Sigmal Language Specification — Part 02
# Core Type System and Universes

[Top](../../) &gt; [Design docs](../) &gt; [Core design](./) &gt; **Part 02**

----

## 1. Universes

Sigmal uses explicit universe levels written as `$N`.

Examples:

- `$0` — ordinary value-level types
- `$1` — types of `$0` types
- `$2` — types of `$1` types

There is no implicit `Type` keyword. `$N` is the canonical notation.

Universe cumulativity policy remains to be fully specified (see Open Questions).

---

## 2. Core Type Constructors

Sigmal’s core type system is based on a small set of foundational constructs:

- Π-types (dependent functions)
- Records (`&`)
- Inductives (`#`)
- Universe levels (`$N`)

These are sufficient to express higher abstractions such as typeclasses,
functors, monads, and effect systems.

---

## 3. Dependent Function Types (Π)

Dependent functions are written using `fn`.

Example:

    id = fn (A : $0) (x : A) { x };

Function types are implicit in `fn` definitions.
Explicit arrow syntax may be surface sugar, but the core form is `fn`.

---

## 4. Record Types (`&`)

Record types correspond to dependent Σ-like structures.

Example:

    Pair = fn (A : $0) (B : $0) {
      &{
        fst : A;
        snd : B;
      }
    };

Record values must provide exactly the declared fields.
No structural subtyping exists.

Records are also used to represent:

- Modules
- Typeclass dictionaries
- Capability objects

---

## 5. Inductive Types (`#`)

Inductive types support multiple constructors.

Example:

    Bool = # {
      True;
      False;
    };

Parameterized inductive:

    Option = fn (A : $0) {
      # {
        None;
        Some(A);
      }
    };

Constructors are namespaced via dot notation:

    Bool.True
    Option.Some

---

## 6. Pattern Matching

Pattern matching is performed via `match`.

Example:

    match x {
      Option.None => ...;
      Option.Some(v) => ...;
    };

Match must be exhaustive.

---

## 7. Typeclasses as Records

Typeclasses are ordinary record types.

Example:

    Functor = fn (F : $0 -> $0) {
      &{
        map : fn (A : $0) (B : $0)
               (f : A -> B) (x : F A) { F B };
      }
    };

Instances are plain record values.

There is no global instance registry.

---

## 8. Open Questions (Type System)

- Universe polymorphism details
- Bottom (`⊥`) and Top (`⊤`) types inclusion
- Exact elaboration rules to minimal core calculus
- Formal normalization guarantees proof outline

---

**Sigmal.org** - *the calculus we can build on*
