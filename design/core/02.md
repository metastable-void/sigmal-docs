# Sigmal Language Specification — Part 02
# Core Type System and Universes

[Top](../../) &gt; [Design docs](../) &gt; [Core design](./) &gt; **Part 02**

----

## 1. Universes

Sigmal uses explicit universe levels written as `$N`.

Examples:

- `$0` — ordinary value-level types
- `$1` — types of `$0` types
- `$2` — types of `$1` types

There is no implicit `Type` keyword. `$N` is the canonical notation.

Universe cumulativity policy remains to be fully specified (see Open Questions).

---

## 2. Core Type Constructors

Sigmal’s core type system is based on a small set of foundational constructs:

- Π-types (dependent functions)
- Records (`&`)
- Inductives (`#`)
- Universe levels (`$N`)

These are sufficient to express higher abstractions such as typeclasses,
functors, monads, and effect systems.

---

## 3. Dependent Function Types (Π)

Dependent functions are written using `fn`.

Example:

    id = fn (A : $0) (x : A) { x };

Function types are implicit in `fn` definitions.
Explicit arrow syntax may be surface sugar, but the core form is `fn`.

---

## 4. Record Types (`&`)

Record types correspond to dependent Σ-like structures.

Example:

    Pair = fn (A : $0) (B : $0) {
      &{
        fst : A;
        snd : B;
      }
    };

Record values must provide exactly the declared fields.
No structural subtyping exists.

Records are also used to represent:

- Modules
- Typeclass dictionaries
- Capability objects

---

## 5. Inductive Types (`#`)

Inductive types support multiple constructors.

Example:

    Bool = # {
      True;
      False;
    };

Parameterized inductive:

    Option = fn (A : $0) {
      # {
        None;
        Some(A);
      }
    };

Constructors are namespaced via dot notation:

    Bool.True
    Option.Some

---

## 6. Pattern Matching

Pattern matching is performed via `match`.

Example:

    match x {
      Option.None => ...;
      Option.Some(v) => ...;
    };

Match must be exhaustive.

---

## 7. Typeclasses as Records

Typeclasses are ordinary record types.

Example:

    Functor = fn (F : $0 -> $0) {
      &{
        map : fn (A : $0) (B : $0)
               (f : A -> B) (x : F A) { F B };
      }
    };

Instances are plain record values.

There is no global instance registry.

---

## 8. Universe polymorphism as compile-time indices

Sigmal has universe levels `$0, $1, $2, ...`, where a value lives in some type `A : $0`, and that type itself is a value of a higher universe, e.g. `A : $1`, etc. Universe polymorphism generalizes definitions over these universe levels without making universe levels term-level values.

### Syntax

Add *universe variables* and (optionally) *offsets* to the existing `$N` universe syntax:

* Universe expressions:

  * numeric: `$0`, `$1`, `$2`, ...
  * variables: `$u`, `$v`, ...
  * offsets: `$u+1`, `$u+2`, ... (compile-time only)

Add a *universe binder* as part of `fn` parameters:

* `fn ($u) ...` binds `$u` in the remainder of the function/type.

Universe variables and offsets are permitted **only in universe positions** (after `$` and inside universe expressions). They are **not term-level values**, cannot be computed by programs, and have **no term-level type**.

### Meaning

A definition with a universe binder is implicitly polymorphic over universe levels. Type checking generates constraints over universe expressions (e.g. requirements like `$u+1` being above `$u`), and those constraints are solved at compile time. This preserves Sigmal’s total core, keeps universes stratified (no `Type : Type`), and avoids introducing a first-class `Level` type.

---

## 9. `Bottom` and `Unit` using universe polymorphism

With universe polymorphism, the “obvious” empty and singleton types can be defined once and reused at any universe.

### `Unit`

`Unit` is definable as the empty record type:

```sigmal
Unit =
  fn ($u) { &{ } };
```

At any universe `$u`, `Unit $u : $u`, and it has exactly one canonical inhabitant (the empty record value):

```sigmal
unit =
  fn ($u) { &{ } };
```

So `unit $u : Unit $u`.

### `Bottom` (⊥, empty type)

`Bottom` is definable as an inductive type with zero constructors:

```sigmal
Bottom =
  fn ($u) { # { } };
```

At any universe `$u`, `Bottom $u : $u`, and it has **no inhabitants** (there is no constructor available to produce a value of that type).

A standard elimination principle (often called `absurd`) can be expressed as:

```sigmal
absurd =
  fn ($u) (A : $u) (x : Bottom $u) { match x { } };
```

Here, `match` is exhaustive; since `Bottom $u` has no constructors, the match has no branches and is still exhaustive.

## 10. Open Questions (Type System)

- Exact elaboration rules to minimal core calculus
- Formal normalization guarantees proof outline

---

**Sigmal.org** - *the calculus we can build on*
