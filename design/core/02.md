# Sigmal Language Specification — Part 02
# Core Type System and Universes

[Top](../../) &gt; [Design docs](../) &gt; [Core design](./) &gt; **Part 02**

---

Sigmal is a **pure, total, structurally typed language**.

The core type system consists of:

* Stratified universes indexed by `Nat`
* Dependent function types and lambda abstraction
* Record types
* Inductive types
* Structural definitional equality
* Explicit evidence for all non-definitional properties
* Compile-time const normalization

There is:

* No nominal type system
* No subtyping
* No global instance registry
* No implicit property resolution

---

## 1. Universes

Universes are indexed by natural numbers.

A universe is written:

```
$ { e }
```

where:

* `e : Nat`
* `e` must be const-normalizable (see Section 7)

Syntactic sugar:

```
$0  ≡  $ { 0 }
$1  ≡  $ { 1 }
$2  ≡  $ { 2 }
```

Universe equality is determined by equality of normalized `Nat` values.

Example:

```
$ { 1 + 1 }  ≡  $ { 2 }
```

if both normalize to the same `Nat`.

Universes are stratified:

If `A : $ { n }`, then:

```
$ { n } : $ { n + 1 }
```

There is no `Type : Type` and no impredicativity.

---

## 2. Dependent Functions and Lambda Abstraction

Sigmal uses a single abstraction form:

```
\ (x : A) { B }
```

This form serves both:

* Dependent function types (Π-types)
* Lambda abstraction terms

If:

* `A : $ { n }`
* `B : $ { m }` under `x : A`

then:

```
\ (x : A) { B } : $ { max n m }
```

Non-dependent arrow sugar:

```
A -> B
```

is equivalent to:

```
\ (_ : A) { B }
```

---

### 2.1 Function Application

Function application uses whitespace and is left-associative.

```
f x
f x y
g f x
```

Parentheses are **not used** for application.

Parentheses are allowed only for grouping expressions when necessary for parsing.

Example:

```
f (g x)
```

Application associates left:

```
f x y    ≡    (f x) y
```

---

## 3. Record Types

Record types are finite maps from **symbol keys** to types.

```
&{
  K1 : T1;
  K2 : T2;
}
```

Each `Ki` is a symbol key (see Section 5).

Field order is irrelevant.

Two record types are definitionally equal iff:

* They contain identical sets of symbol keys
* Corresponding field types are definitionally equal

Records are structural.

Record values:

```
&{
  K1 = v1;
  K2 = v2;
}
```

---

## 4. Inductive Types

Inductive types are written:

```
#{
  C1;
  C2(T);
}
```

Each constructor `Ci` is a symbol key.

Constructors may carry arguments.

Two inductive types are definitionally equal iff:

* They contain identical constructor symbol keys
* Corresponding constructor argument types are definitionally equal

Pattern matching:

```
^ x {
  C1 => ...;
  C2 y => ...;
}
```

must be exhaustive.

---

## 5. Symbols (`Sym`)

`Sym` is a primitive value type:

```
Sym : $0
```

Symbols are semantic identity atoms used as:

* Record field keys
* Inductive constructor tags
* Module path segments
* Other structural keys

Symbols are ordinary runtime values.

Symbol equality is structural.

There is no global registry of symbols.

---

## 6. Symbol Injection

Symbol injection syntax:

```
@{ e }
```

where:

* `e : Sym`
* `e` must be const-normalizable

`@{ e }` is valid only in symbol-key positions.

It is not a term of type `Sym`.

Bare identifiers in key positions are sugar for:

```
@{ TextSym "identifier" }
```

---

## 7. Const-Normalizable Expressions

Certain syntactic positions require compile-time normalization.

An expression `e` is const-normalizable if:

1. `e` typechecks in the pure fragment
2. `e` is effect-free
3. `e` terminates
4. `e` reduces to a value

We write:

```
Γ ⊢const e ⇓ v
```

Const positions include:

* Universe levels `$ { e }`
* Symbol injection `@{ e }`
* Any structural parameter declared const-required

Const evaluation is:

* Deterministic
* Total
* Effect-free

---

## 8. Definitional Equality

Definitional equality is structural and normalization-based.

It includes:

* β-reduction
* Structural comparison of:

  * Functions
  * Records (by symbol keys)
  * Inductives (by constructor keys)
  * Universes (normalized `Nat`)
  * Symbols (structural equality)

No nominal identity exists.

---

## 9. No Runtime Reflection into Types

Runtime values cannot influence type structure unless they appear in const-normalizable positions.

In particular:

* A runtime `Sym` cannot dynamically determine record fields.
* There is no `Sym -> Type` mapping.
* There is no implicit reflection mechanism.

Type structure depends only on:

* Syntax
* Const-normalizable expressions
* Definitional equality

---

## 10. Explicit Evidence Discipline

Sigmal performs no implicit property resolution.

If a function requires a property, it must receive a witness explicitly.

Example:

```
Eq A = &{
  eq : A -> A -> Bool;
}
```

A function requiring equality:

```
\ (A : $ { n })
  (eqA : Eq A)
  (x : A)
  (y : A)
{ ... }
```

The compiler never inserts such witnesses automatically.

The only automatic reasoning mechanism is definitional equality.

---

## 11. Typeclasses

Typeclasses are ordinary record types.

There is:

* No global instance registry
* No coherence mechanism
* No implicit resolution

Instances are explicit values.

---

## 12. Literals

Literal interpretation does not depend on implicit property resolution.

Conversions from literals to typed values must be explicit.

---

## 13. Summary

The Sigmal core type system is:

* Pure
* Total
* Structural
* Universe-stratified
* Symbol-keyed
* Explicit in all properties
* Free of global registries
* Deterministic in compile-time normalization

Type identity is structural and determined by normalized form.

All non-definitional properties must be passed explicitly as values.

---

**Sigmal.org** - *the calculus we can build on*
