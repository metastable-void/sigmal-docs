# Sigmal Language Specification — Part 05
# Abstractions: Functor, Applicative, Monad, and Effect Encoding

[Top](../../) &gt; [Design docs](../) &gt; [Core design](./) &gt; **Part 05**

----

## 1. Typeclasses as Records

In Sigmal, typeclasses are ordinary record types.
There is no special language-level typeclass mechanism.

Example: Functor

    Functor = fn (F : $0 -> $0) {
      &{
        map :
          fn (A : $0) (B : $0)
             (f : A -> B)
             (x : F A) { F B };
      }
    };

An instance is simply a record value of this type.

---

## 2. Applicative

    Applicative = fn (F : $0 -> $0) {
      &{
        pure :
          fn (A : $0) (x : A) { F A };

        ap :
          fn (A : $0) (B : $0)
             (ff : F (A -> B))
             (fa : F A) { F B };
      }
    };

---

## 3. Monad

    Monad = fn (M : $0 -> $0) {
      &{
        pure :
          fn (A : $0) (x : A) { M A };

        bind :
          fn (A : $0) (B : $0)
             (m : M A)
             (f : A -> M B) { M B };
      }
    };

No implicit instance resolution exists.
All dictionaries must be passed explicitly.

---

## 4. Downcasting Between Abstractions

Because these abstractions are records,
conversion functions can be written explicitly.

Example:

    monadToApplicative =
      fn (M : $0 -> $0)
         (mon : Monad M) {
        &{
          pure = mon.pure;
          ap = fn (A : $0) (B : $0)
                   (ff : M (A -> B))
                   (fa : M A) {
                 mon.bind A B fa
                   (fn (a : A) {
                      mon.bind (A -> B) B ff
                        (fn (f : A -> B) {
                           mon.pure B (f a)
                        })
                   })
               };
        }
      };

No global coherence or collision issues arise.

---

## 5. Generic Effect Encoding (Free Construction)

Sigmal does not bake effects into the language.

Effects are encoded purely via data types.

### Operation Frame (Σ-pack)

    OpFrame =
      fn (Op : $0 -> $0) (A : $0) {
        &{
          X  : $0;
          op : Op X;
          k  : X -> A;
        }
      };

### Free Construction

    Free =
      fn (Op : $0 -> $0) (A : $0) {
        # {
          Pure(A);
          Op(OpFrame Op (Free Op A));
        }
      };

This encodes effectful programs as pure data.

---

## 6. Handlers

A handler is a record:

    Handler =
      fn (Op : $0 -> $0) {
        &{
          handle :
            fn (X : $0) (op : Op X) { X };
        }
      };

Interpretation is explicit via a function such as `runFree`.

---

## 7. Capabilities as Explicit Values

Capabilities (I/O, system interfaces, etc.) are explicit records.
No ambient world exists.

This allows:

- Freestanding environments
- Kernel development
- Sandboxed execution
- Controlled capability injection

---

## 8. Open Questions (Abstractions)

- Law encoding strategy (Functor/Monad laws in type system?)
- Effect system optimizations (e.g., fusion)
- Ergonomic surface sugar for do-notation
- Compiler specialization of dictionary passing

---

**Sigmal.org** - *the calculus we can build on*
